<!DOCTYPE html>
<html>
<head>
<title>Tuner</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" type="text/css" href="../style.css" />
<style>
canvas {display:block;border:1px solid;}
</style>
</head>
<body>

<h1><span id="qr"><a id="qrcode"></a></span> Tuner</h1>
<p>
<button id="btn">start</button>
</p><p>
<canvas id="can"></canvas>
</p><p>
<a href=index.html>Back</a>
</p>

<script>
var audioCtx;
var running;
var btn = document.getElementById('btn');
var out = document.getElementById('out');
var can = document.getElementById('can');
var ctx = can.getContext('2d');
var animationId;
var note = ['A', 'A♯/B♭', 'B', 'C', 'C♯/D♭', 'D', 'D♯/E♭', 'E', 'F', 'F♯/G♭', 'G', 'G♯/A♭'];
var micSource, lp, hp, analyser;
async function start() {
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  stream = await navigator.mediaDevices.getUserMedia({
    audio: true,
    echoCancellation: false,
    noiseSuppression: false,
    autoGainControl: false
  });

  micSource = audioCtx.createMediaStreamSource(stream);
  hp = audioCtx.createBiquadFilter();
  hp.type = "highpass";
  hp.frequency.value = 30;
  hp.Q.value = 0.7;
  lp = audioCtx.createBiquadFilter();
  lp.type = "lowpass";
  lp.frequency.value = 1200;
  lp.Q.value = 0.7;
  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 2048;
  analyser.smoothingTimeConstant = 0;
  micSource.connect(hp).connect(lp).connect(analyser);
  running = true;
  btn.innerHTML = 'stop';
  update();
}
function stop() {
  if (audioCtx) {
    audioCtx.close();
    audioCtx = null;
  }
  btn.innerHTML = 'start';
  running = false;
}
btn.addEventListener("click", function() {
  if (running) stop();
  else start().catch(function (err) {
    console.error(err);
    alert("Microphone access failed.");
  });
});
const width = can.width;
var wave = new Float32Array(width);
function adjust(data) {
  const sz = 2048;
  const a = new Array(sz).fill(0);
  var i, j;
  for (i = 0; i < sz; i++) for (j = 0; j < width; j++) a[i] += data[i + j] * (wave[j] - j / width);
  j = 0;
  for (i = 0; i < sz; i++) if (a[i] > a[j]) j = i;
  wave = data.slice(j, j + width);
}
function update() {
  if (!running) return;
  const bufferLength = analyser.frequencyBinCount;
  const data = new Float32Array(bufferLength);
  analyser.getFloatTimeDomainData(data);
  adjust(data);

  ctx.fillStyle = "#fff";
  ctx.fillRect(0, 0, can.width, can.height);
  ctx.strokeStyle = "#000";
  ctx.lineWidth = 2;
  ctx.beginPath();
  var dx = 1; // can.width / bufferLength;
  var x = 0, y;
  var i;
  for (i = 0; i < can.width; i++) {
    y = can.height / 2 + wave[i] * can.height / 2;
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
    x += dx;
  }
  ctx.stroke();
  var f = median(autoCorrelate(data, audioCtx.sampleRate));
  if (f) {
    var z = Math.log2(f / 440);
    z = (z - Math.floor(z)) * 12;
    y = can.height / 8;
    x = can.width / 2;
    dx = x * (Math.round(z) - z);
    ctx.font = "16px serif";
    ctx.textAlign = "center";
    ctx.fillStyle = "blue";
    ctx.fillText(note[Math.round(z) % 12], x + dx, y);
    ctx.fillText(note[Math.round(z + 11) % 12], dx, y);
    ctx.fillText(note[Math.round(z + 1) % 12], x + x + dx, y);
    x = dx - x;
    while (x <= can.width) {
      if (x > 0) ctx.fillText('*', x, y * 2);
      x += can.width / 16;
    }
    ctx.fillStyle = "red";
    ctx.fillText('⇑', can.width / 2, y * 3);
  }
  animationId = requestAnimationFrame(update);
}
function autoCorrelate(buffer, sampleRate) {
  var i, j, n, x, y0, y1, y2;
  const a = new Array(buffer.length).fill(0);
  var m = 0;
  for (i = 0; i < buffer.length; i++) {
    if (m < buffer[i]) m = buffer[i];
  }
  x = 0;
  for (i = 0; i < buffer.length; i++) x += buffer[i] * buffer[i];
  if (x < .5) return;
  for (i = 0; i < buffer.length; i++) {
    for (j = 0; j < buffer.length - i; j++) {
      a[i] += buffer[j] * buffer[j + i];
    }
  }
  // skip the high frequency artifacts
  for (n = 12; n < buffer.length - 1; n++) if (a[n] > a[n - 1]) break;
  // find the peak
  x = a[n];
  for (i = n; i < buffer.length - 1; i++) if (a[i] > x) { n = i; x = a[i]; }
  // quadratic subsample
  y0 = a[n - 1];
  y1 = a[n];
  y2 = a[n + 1];
  x = 2 * (2 * y1 - y0 - y2);
  if (x) n -= (y2 - y0) / x;
  return sampleRate / n;
}
const med = [];
function median(x) {
  if (x) med.push(x);
  if (med.length > 7) med.shift();
  if (!med.length) return;
  var m = med.slice().sort(function(a, b) { return a - b; });
  var n = Math.ceil(m.length / 2);
  return m.length & 1 ? m[n] : (m[n] + m[n - 1]) / 2;
}
</script>

<script src="https://cdn.jsdelivr.net/npm/qr-min"></script>
<script src="../javascript/common.js"></script>
</body>
</html>